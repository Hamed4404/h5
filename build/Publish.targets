<Project>

  <!-- Inserts the Razor VSIX to the VS drop share -->
  <Target Name="RunVSDrop" DependsOnTargets="GetToolsets" Condition="'$(PublishToVSDrop)' == 'true'">
    <Error Text="Cannot publish unsigned files to VS drops. Set SignType to 'real' to ensuring files are signed first."
      Condition=" '$(SignType)' != 'real'" />

    <Error Text="MSBuild could not be located."
      Condition="'$(VisualStudioMSBuildx86Path)'==''" />

    <ItemGroup>
      <SignedRazorVSIX Include="$(SignedVSIXPath)*.vsix" />

      <MSBuildExeArgs Include="
        $(MSBuildThisFileDirectory)vsdrop\drop.msbuild;
        /t:BuildAndPublishManifest;
        /p:SignedVsixPath=$(SignedVSIXPath);
        /p:RepositoryRoot=$(RepositoryRoot);
        /p:ManifestRepositoryName=AspNetCore/%(SignedRazorVSIX.FileName);
        /p:ManifestBuildBranch=$(BuildBranch);
        /p:ManifestBuildNumber=$(BuildNumber)" />
    </ItemGroup>

    <Run FileName="$(VisualStudioMSBuildx86Path)" Arguments="@(MSBuildExeArgs)" Condition="Exists($(RazorVSIXFullPath))" />
  </Target>

  <Target Name="GetPackagesToPublish">
    <ItemGroup>
      <PackagesToPublish Include="$(PackagesOutputPath)*.nupkg" />
      <PackagesToPublish Include="$(PackagesOobOutputPath)*.nupkg" />
      <PackagesToPublish Include="$(SymbolsOutputPath)*.nupkg" />
    </ItemGroup>
  </Target>

  <Target Name="GetFilesToPublish">
    <ItemGroup>
      <!--
      PublishToAzure that is defined in BuildTools looks for itemgroups named PackagesToPublish and FilesToPublish to publish to MyGet.
      Ensure that this only contains artifacts we produce (and not mirrored dependencies) since that would result in conflicts.

      BlobFileRelativePathBase is set by default in KoreBuild to 'assets/'.
       -->
      <_SharedFxFilesToPublish Include="$(SharedFxOutputPath)*" />
      <_SharedFxLatestBadgeToPublish Include="$(DepsDirectory)assets\Runtime\*\*.svg" />
      <_SharedFxLatestPointerToPublish Include="$(DepsDirectory)assets\Runtime\*\latest.aspnetcore.version" />
    </ItemGroup>
  </Target>

  <!-- For orchestrated build -->
  <Target Name="GetAzureFilesToPublish" 
    BeforeTargets="PublishToAzure" 
    DependsOnTargets="GetPackagesToPublish;GetFilesToPublish"
    Condition="'$(PublishToAzureBlob)' == 'true'">

    <ItemGroup>
      <FilesToPublish Include="@(_SharedFxFilesToPublish)" RelativeBlobPath="$(BlobFileRelativePathBase)Runtime/$(PackageVersion)/%(_SharedFxFilesToPublish.FileName)%(_SharedFxFilesToPublish.Extension)" />
    </ItemGroup>

    <Message Text="Publishing %(FilesToPublish.Identity)" Importance="High" />
  </Target>

  <!-- For non-orchestrated builds (temporary until PCP pushes to dotnetcli for us) -->
  <Target Name="PublishToDotnetCliFeed" 
    DependsOnTargets="GetFilesToPublish"
    Condition="'$(PublishToDotnetCliAzureBlob)' == 'true'">

    <Error Condition="@(_SharedFxLatestPointerToPublish->Count()) &gt; 1" Text="More than one 'latest.aspnetcore.version' file was found. Cannot publish both." />

    <ItemGroup>
      <!-- unlike PCP, we don't want to prefix publishing with BlobFileRelativePathBase-->
      <FilesToPublish Include="@(_SharedFxFilesToPublish)" RelativeBlobPath="Runtime/$(PackageVersion)/%(_SharedFxFilesToPublish.FileName)%(_SharedFxFilesToPublish.Extension)" />

      <FilesToPublish Include="@(_SharedFxLatestBadgeToPublish)" RelativeBlobPath="Runtime/$(SharedFxCliBlobChannel)/%(_SharedFxLatestBadgeToPublish.FileName)%(_SharedFxLatestBadgeToPublish.Extension)">
        <CacheControl>no-cache, no-store, must-revalidate</CacheControl>
        <ContentType>image/svg+xml</ContentType>
        <Overwrite>true</Overwrite>
      </FilesToPublish>

      <FilesToPublish Include="@(_SharedFxLatestPointerToPublish)" RelativeBlobPath="Runtime/$(SharedFxCliBlobChannel)/latest.aspnetcore.version">
        <CacheControl>no-cache, no-store, must-revalidate</CacheControl>
        <ContentType>text/plain</ContentType>
        <Overwrite>true</Overwrite>
      </FilesToPublish>
    </ItemGroup>

    <RepoTasks.PublishToAzureBlob 
        AccountName="$(PublishDotnetCliAccountName)"
        SharedAccessToken="$(DotnetCliAccessToken)"
        ContainerName="$(PublishDotnetCliContainerName)"
        Files="@(FilesToPublish)" />
  </Target>


  <Target Name="PushNuGetPackages" DependsOnTargets="GetPackagesToPublish" Condition="'$(PublishToMyget)' == 'true'">
    <Error Text="Cannot publish unsigned files to MyGet. Set SignType to 'real' to ensuring files are signed first."
      Condition=" '$(SignType)' != 'real'" />

    <!-- Contains the super set of packages that we'd like to publish to MyGet and Azure blob -->
    <ItemGroup>
      <_PackagesToPublish Include="@(PackagesToPublish)" />
      <_PackagesToPublish Include="$(DepsDirectory)noship\*.nupkg" />
      <_PackagesToPublish Include="$(DepsDirectory)mirror\*.nupkg" />
      <_PackagesToPublish Include="$(DepsDirectory)lineups\*.nupkg" />
    </ItemGroup>

    <Error Message="No packages found to publish" Condition="@(_PackagesToPublish->Count()) == 0" />

    <PushNuGetPackages
      Packages="@(_PackagesToPublish)"
      Feed="$(PublishFeed)"
      ApiKey="$(APIKey)" />
  </Target>

  <ItemGroup>
    <NpmModuleArtifact Include="$(DepsDirectory)build\*.tgz" />
  </ItemGroup>

  <Target Name="PushNPMPackages" Condition="@(NpmModuleArtifact->Count()) != 0 AND '$(PublishToMyget)' == 'true'">
    <Error Text="Missing required property: NpmRegistry"  Condition=" '$(NpmRegistry)' == '' "/>

    <PropertyGroup>
      <AuthTokenSetting>$(NpmRegistry.Replace("https:", "")):_authToken</AuthTokenSetting>
    </PropertyGroup>

    <Exec Command="npm config set &quot;$(AuthTokenSetting)&quot; $(APIKey)" Condition=" '$(APIKey)' != '' " />
    <Exec Command="npm publish --registry $(NpmRegistry) &quot;%(NpmModuleArtifact.Identity)&quot;"
          ContinueOnError="true">
      <Output TaskParameter="ExitCode" ItemName="ExitCodes" />
    </Exec>
    <Exec Command="npm config delete $(AuthTokenSetting)" Condition=" '$(APIKey)' != '' "/>
    <Error Text="Publishing npm modules failed" Condition="%(ExitCodes.Identity) > 0"/>
  </Target>

</Project>
