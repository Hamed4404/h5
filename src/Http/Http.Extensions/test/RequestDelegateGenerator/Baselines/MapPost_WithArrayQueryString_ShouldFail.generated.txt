//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

namespace Microsoft.AspNetCore.Builder
{
    %GENERATEDCODEATTRIBUTE%
    internal class SourceKey
    {
        public string Path { get; init; }
        public int Line { get; init; }

        public SourceKey(string path, int line)
        {
            Path = path;
            Line = line;
        }
    }

    // This class needs to be internal so that the compiled application
    // has access to the strongly-typed endpoint definitions that are
    // generated by the compiler so that they will be favored by
    // overload resolution and opt the runtime in to the code generated
    // implementation produced here.
    %GENERATEDCODEATTRIBUTE%
    internal static class GenerateRouteBuilderEndpoints
    {
        private static readonly string[] GetVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Get };
        private static readonly string[] PostVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Post };
        private static readonly string[] PutVerb = new[]  { global::Microsoft.AspNetCore.Http.HttpMethods.Put };
        private static readonly string[] DeleteVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Delete };
        private static readonly string[] PatchVerb = new[] { global::Microsoft.AspNetCore.Http.HttpMethods.Patch };

        internal static global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder MapPost(
            this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder endpoints,
            [global::System.Diagnostics.CodeAnalysis.StringSyntax("Route")] string pattern,
            global::System.Func<global::System.String[], global::System.Int32> handler,
            [global::System.Runtime.CompilerServices.CallerFilePath] string filePath = "",
            [global::System.Runtime.CompilerServices.CallerLineNumber]int lineNumber = 0)
        {
            return global::Microsoft.AspNetCore.Http.Generated.GeneratedRouteBuilderExtensionsCore.MapCore(
                endpoints,
                pattern,
                handler,
                PostVerb,
                filePath,
                lineNumber);
        }

    }
}

namespace Microsoft.AspNetCore.Http.Generated
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Text.Json;
    using System.Text.Json.Serialization.Metadata;
    using System.Threading.Tasks;
    using System.IO;
    using Microsoft.AspNetCore.Routing;
    using Microsoft.AspNetCore.Routing.Patterns;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Http.Json;
    using Microsoft.AspNetCore.Http.Metadata;
    using Microsoft.Extensions.DependencyInjection;
    using Microsoft.Extensions.FileProviders;
    using Microsoft.Extensions.Logging;
    using Microsoft.Extensions.Primitives;
    using Microsoft.Extensions.Options;

    using MetadataPopulator = System.Func<System.Reflection.MethodInfo, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions?, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult>;
    using RequestDelegateFactoryFunc = System.Func<System.Delegate, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult?, Microsoft.AspNetCore.Http.RequestDelegateResult>;
    delegate void LogOrThrowExceptionAction(int eventId, string message, Exception? exceptipon = null, int statusCode = StatusCodes.Status400BadRequest);

    file static class GeneratedRouteBuilderExtensionsCore
    {

        private static readonly Dictionary<(string, int), (MetadataPopulator, RequestDelegateFactoryFunc)> map = new()
        {
            [(@"TestMapActions.cs", 25)] = (
                (methodInfo, options) =>
                {
                    Debug.Assert(options?.EndpointBuilder != null, "EndpointBuilder not found.");
                    options.EndpointBuilder.Metadata.Add(new SourceKey(@"TestMapActions.cs", 25));
                    return new RequestDelegateMetadataResult { EndpointMetadata = options.EndpointBuilder.Metadata.AsReadOnly() };
                },
                (del, options, inferredMetadataResult) =>
                {
                    var handler = (System.Func<global::System.String[], global::System.Int32>)del;
                    EndpointFilterDelegate? filteredInvocation = null;
                    var serviceProvider = options?.ServiceProvider ?? options?.EndpointBuilder?.ApplicationServices;
                    var logOrThrowException = GetLogOrThrowException(serviceProvider, options);
                    var serviceProviderIsService = serviceProvider?.GetService<IServiceProviderIsService>();
                    var p_JsonBodyOrServiceResolver = ResolveJsonBodyOrService<global::System.String[]>(logOrThrowException, "string[]", "p", serviceProviderIsService);
                    var serializerOptions = serviceProvider?.GetService<IOptions<JsonOptions>>()?.Value.SerializerOptions ?? new JsonOptions().SerializerOptions;
                    var jsonTypeInfo =  (JsonTypeInfo<global::System.Int32>)serializerOptions.GetTypeInfo(typeof(global::System.Int32));

                    if (options?.EndpointBuilder?.FilterFactories.Count > 0)
                    {
                        filteredInvocation = GeneratedRouteBuilderExtensionsCore.BuildFilterDelegate(ic =>
                        {
                            if (ic.HttpContext.Response.StatusCode == 400)
                            {
                                return ValueTask.FromResult<object?>(Results.Empty);
                            }
                            return ValueTask.FromResult<object?>(handler(ic.GetArgument<global::System.String[]>(0)!));
                        },
                        options.EndpointBuilder,
                        handler.Method);
                    }

                    async Task RequestHandler(HttpContext httpContext)
                    {
                        var wasParamCheckFailure = false;
                        // Endpoint Parameter: p (Type = string[], IsOptional = False, IsParsable = False, IsArray = True, Source = JsonBodyOrService)
                        var p_resolveJsonBodyOrServiceResult = await p_JsonBodyOrServiceResolver(httpContext, false);
                        var p_local = p_resolveJsonBodyOrServiceResult.Item2;
                        if (!p_resolveJsonBodyOrServiceResult.Item1)
                        {
                            return;
                        }

                        if (wasParamCheckFailure)
                        {
                            httpContext.Response.StatusCode = 400;
                            return;
                        }
                        httpContext.Response.ContentType ??= "application/json";
                        var result = handler(p_local!);
                        await httpContext.Response.WriteAsJsonAsync(result, jsonTypeInfo);
                    }

                    async Task RequestHandlerFiltered(HttpContext httpContext)
                    {
                        var wasParamCheckFailure = false;
                        // Endpoint Parameter: p (Type = string[], IsOptional = False, IsParsable = False, IsArray = True, Source = JsonBodyOrService)
                        var p_resolveJsonBodyOrServiceResult = await p_JsonBodyOrServiceResolver(httpContext, false);
                        var p_local = p_resolveJsonBodyOrServiceResult.Item2;
                        if (!p_resolveJsonBodyOrServiceResult.Item1)
                        {
                            return;
                        }

                        if (wasParamCheckFailure)
                        {
                            httpContext.Response.StatusCode = 400;
                        }
                        var result = await filteredInvocation(EndpointFilterInvocationContext.Create<global::System.String[]>(httpContext, p_local!));
                        await GeneratedRouteBuilderExtensionsCore.ExecuteObjectResult(result, httpContext);
                    }

                    RequestDelegate targetDelegate = filteredInvocation is null ? RequestHandler : RequestHandlerFiltered;
                    var metadata = inferredMetadataResult?.EndpointMetadata ?? ReadOnlyCollection<object>.Empty;
                    return new RequestDelegateResult(targetDelegate, metadata);
                }),

        };

        internal static RouteHandlerBuilder MapCore(
            this IEndpointRouteBuilder routes,
            string pattern,
            Delegate handler,
            IEnumerable<string> httpMethods,
            string filePath,
            int lineNumber)
        {
            var (populateMetadata, createRequestDelegate) = map[(filePath, lineNumber)];
            return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate);
        }

        private static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, MethodInfo mi)
        {
            var routeHandlerFilters =  builder.FilterFactories;
            var context0 = new EndpointFilterFactoryContext
            {
                MethodInfo = mi,
                ApplicationServices = builder.ApplicationServices,
            };
            var initialFilteredInvocation = filteredInvocation;
            for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)
            {
                var filterFactory = routeHandlerFilters[i];
                filteredInvocation = filterFactory(context0, filteredInvocation);
            }
            return filteredInvocation;
        }

        private static Task ExecuteObjectResult(object? obj, HttpContext httpContext)
        {
            if (obj is IResult r)
            {
                return r.ExecuteAsync(httpContext);
            }
            else if (obj is string s)
            {
                return httpContext.Response.WriteAsync(s);
            }
            else
            {
                return httpContext.Response.WriteAsJsonAsync(obj);
            }
        }

        private static async ValueTask<(bool, T?)> TryResolveBodyAsync<T>(HttpContext httpContext, bool allowEmpty, LogOrThrowExceptionAction logOrThrowException, string parameterTypeName, string parameterName, bool isInferred = false)
        {
            var feature = httpContext.Features.Get<Microsoft.AspNetCore.Http.Features.IHttpRequestBodyDetectionFeature>();

            if (feature?.CanHaveBody == true)
            {
                if (!httpContext.Request.HasJsonContentType())
                {
                    var message = string.Format(CultureInfo.InvariantCulture, "Expected a supported JSON media type but got \"{0}\".", httpContext.Request.ContentType);
                    logOrThrowException(6, message, null, StatusCodes.Status415UnsupportedMediaType);
                    httpContext.Response.StatusCode = StatusCodes.Status415UnsupportedMediaType;
                    return (false, default);
                }
                try
                {
                    var bodyValue = await httpContext.Request.ReadFromJsonAsync<T>();
                    if (!allowEmpty && bodyValue == null)
                    {
                        if (!isInferred)
                        {
                            var message = string.Format(CultureInfo.InvariantCulture, "Required parameter \"{0} {1}\" was not provided from {2}.", parameterTypeName, parameterName, "body");
                            logOrThrowException(4, message, null);
                        }
                        else
                        {
                            var message = string.Format(CultureInfo.InvariantCulture, "Implicit body inferred for parameter \"{0}\" but no body was provided. Did you mean to use a Service instead?", parameterName);
                            logOrThrowException(5, message, null);
                        }
                        httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
                        return (false, bodyValue);
                    }
                    return (true, bodyValue);
                }
                catch (IOException ioException)
                {
                    logOrThrowException(1, "Reading the request body failed with an IOException.", ioException, StatusCodes.Status500InternalServerError);
                    return (false, default);
                }
                catch (System.Text.Json.JsonException jsonException)
                {
                    var message = string.Format(CultureInfo.InvariantCulture, "Failed to read parameter \"{0} {1}\" from the request body as JSON.", parameterTypeName, parameterName);
                    logOrThrowException(2, message, jsonException, StatusCodes.Status400BadRequest);
                    httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
                    return (false, default);
                }
            }
            else if (!allowEmpty)
            {
                httpContext.Response.StatusCode = StatusCodes.Status400BadRequest;
            }

            return (allowEmpty, default);
        }
        private static Func<HttpContext, bool, ValueTask<(bool, T?)>> ResolveJsonBodyOrService<T>(LogOrThrowExceptionAction logOrThrowException, string parameterTypeName, string parameterName, IServiceProviderIsService? serviceProviderIsService = null)
        {
            if (serviceProviderIsService is not null)
            {
                if (serviceProviderIsService.IsService(typeof(T)))
                {
                    return static (httpContext, isOptional) => new ValueTask<(bool, T?)>((true, httpContext.RequestServices.GetService<T>()));
                }
            }
            return (httpContext, isOptional) => TryResolveBodyAsync<T>(httpContext, isOptional, logOrThrowException, parameterTypeName, parameterName, isInferred: true);
        }
        private static LogOrThrowExceptionAction GetLogOrThrowException(IServiceProvider? serviceProvider, RequestDelegateFactoryOptions? options)
        {
            var loggerFactory = serviceProvider?.GetRequiredService<ILoggerFactory>();
            var rdgLogger = loggerFactory?.CreateLogger("Microsoft.AspNetCore.Http.RequestDelegateGenerator.RequestDelegateGenerator");
            void logOrThrowException(int eventId, string message, Exception? exception = null, int statusCode = StatusCodes.Status400BadRequest)
            {
                if ((options?.ThrowOnBadRequest ?? false) && eventId != 1)
                {
                    if (exception != null)
                    {
                        throw new BadHttpRequestException(message, statusCode, exception);
                    }
                    throw new BadHttpRequestException(message, statusCode);
                }
                rdgLogger?.LogDebug(eventId, exception, message);
            }
            return logOrThrowException;
        }

    }
}
