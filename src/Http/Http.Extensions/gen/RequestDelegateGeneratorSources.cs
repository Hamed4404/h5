// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

namespace Microsoft.AspNetCore.Http.Generators;

internal static class RequestDelegateGeneratorSources
{
    private const string SourceHeader = """
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
using global::System;
using global::System.Collections;
using global::System.Collections.Generic;
using global::System.Diagnostics;
using global::System.Linq;
using global::System.Reflection;
using global::System.Threading.Tasks;
using global::System.IO;
using global::Microsoft.AspNetCore.Routing;
using global::Microsoft.AspNetCore.Routing.Patterns;
using global::Microsoft.AspNetCore.Builder;
using global::Microsoft.AspNetCore.Http;
using global::Microsoft.Extensions.DependencyInjection;
using global::Microsoft.Extensions.FileProviders;
using global::Microsoft.Extensions.Primitives;
using MetadataPopulator = System.Func<System.Reflection.MethodInfo, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions?, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult>;
using RequestDelegateFactoryFunc = System.Func<System.Delegate, Microsoft.AspNetCore.Http.RequestDelegateFactoryOptions, Microsoft.AspNetCore.Http.RequestDelegateMetadataResult?, Microsoft.AspNetCore.Http.RequestDelegateResult>;
""";

    public static string GeneratedCodeAttribute => $@"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{typeof(RequestDelegateGeneratorSources).Assembly.FullName}"", ""{typeof(RequestDelegateGeneratorSources).Assembly.GetName().Version}"")]";

    public static string GetGeneratedRouteBuilderExtensionsSource(string genericThunks, string thunks, string endpoints) => $$"""
{{SourceHeader}}

namespace Microsoft.AspNetCore.Builder
{
    {{GeneratedCodeAttribute}}
    internal class SourceKey
    {
        public string Path { get; init; }
        public int Line { get; init; }

        public SourceKey(string path, int line)
        {
            Path = path;
            Line = line;
        }
    }
}

{{GeneratedCodeAttribute}}
// This class needs to be internal so that the compiled application
// has access to the strongly-typed endpoint definitions that are
// generated by the compiler so that they will be favored by
// overload resolution and opt the runtime in to the code generated
// implementation produced here.
internal static class GenerateRouteBuilderEndpoints
{
    private static readonly string[] GetVerb = new[] { HttpMethods.Get };
    private static readonly string[] PostVerb = new[] { HttpMethods.Post };
    private static readonly string[] PutVerb = new[]  { HttpMethods.Put };
    private static readonly string[] DeleteVerb = new[] { HttpMethods.Delete };
    private static readonly string[] PatchVerb = new[] { HttpMethods.Patch };

    {{endpoints}}
}

{{GeneratedCodeAttribute}}
file static class GeneratedRouteBuilderExtensionsCore
{
    internal static class GenericThunks<T>
    {
        public static readonly global::System.Collections.Generic.Dictionary<(string, int), (MetadataPopulator, RequestDelegateFactoryFunc)> map = new()
        {
            {{genericThunks}}
        };
    }

    internal static readonly global::System.Collections.Generic.Dictionary<(string, int), (MetadataPopulator, RequestDelegateFactoryFunc)> map = new()
    {
        {{thunks}}
    };

    internal static global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder MapCore<T>(
        this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder routes,
        string pattern,
        System.Delegate handler,
        IEnumerable<string> httpMethods,
        string filePath,
        int lineNumber)
    {
        var (populateMetadata, createRequestDelegate) = GenericThunks<T>.map[(filePath, lineNumber)];
        return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate);
    }

    internal static global::Microsoft.AspNetCore.Builder.RouteHandlerBuilder MapCore(
        this global::Microsoft.AspNetCore.Routing.IEndpointRouteBuilder routes,
        string pattern,
        System.Delegate handler,
        IEnumerable<string> httpMethods,
        string filePath,
        int lineNumber)
    {
        var (populateMetadata, createRequestDelegate) = map[(filePath, lineNumber)];
        return RouteHandlerServices.Map(routes, pattern, handler, httpMethods, populateMetadata, createRequestDelegate);
    }

    internal static EndpointFilterDelegate BuildFilterDelegate(EndpointFilterDelegate filteredInvocation, EndpointBuilder builder, global::System.Reflection.MethodInfo mi)
    {
        var routeHandlerFilters =  builder.FilterFactories;
        var context0 = new EndpointFilterFactoryContext
        {
            MethodInfo = mi,
            ApplicationServices = builder.ApplicationServices,
        };
        var initialFilteredInvocation = filteredInvocation;
        for (var i = routeHandlerFilters.Count - 1; i >= 0; i--)
        {
            var filterFactory = routeHandlerFilters[i];
            filteredInvocation = filterFactory(context0, filteredInvocation);
        }
        return filteredInvocation;
    }

    internal static void PopulateMetadata<T>(System.Reflection.MethodInfo method, EndpointBuilder builder) where T : Microsoft.AspNetCore.Http.Metadata.IEndpointMetadataProvider
    {
        T.PopulateMetadata(method, builder);
    }

    internal static void PopulateMetadata<T>(System.Reflection.ParameterInfo parameter, EndpointBuilder builder) where T : Microsoft.AspNetCore.Http.Metadata.IEndpointParameterMetadataProvider
    {
        T.PopulateMetadata(parameter, builder);
    }

    internal static Task ExecuteObjectResult(object? obj, HttpContext httpContext)
    {
        if (obj is IResult r)
        {
            return r.ExecuteAsync(httpContext);
        }
        else if (obj is string s)
        {
            return httpContext.Response.WriteAsync(s);
        }
        else
        {
            return httpContext.Response.WriteAsJsonAsync(obj);
        }
    }
}
""";
}
