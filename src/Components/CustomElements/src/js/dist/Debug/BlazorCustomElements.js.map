{"version":3,"file":"BlazorCustomElements.js","mappings":"yBAGCA,OAAeC,4BAA8B,SAAsCC,EAAqBC,GACvGC,eAAeC,OAAOH,EAAa,cAA4CI,EAClEC,gCACT,OAAOD,EAAoBE,sBAAsBL,GAGnDM,cACEC,MAAMP,OAKZ,MAAaG,UAA4BK,YAgBvCF,YAAYN,GACVO,QAfM,KAAAE,iBAAkD,GAElD,KAAAC,0BAA2B,EAC3B,KAAAC,aAAc,EAGf,KAAAC,kBAAoBC,KAYzBA,KAAKC,mBAAqB,GAC1Bd,EAAWe,SAAQC,IACjB,MAAMC,EAAgBC,EAAUF,EAAUG,MAC1CN,KAAKC,mBAAmBG,GAAiBD,KAK3CH,KAAKO,yBAA2BC,QAAQC,UAAUC,MAAK,KACrDV,KAAKH,0BAA2B,EACzBc,OAAOC,eAAeC,IAAIb,KAAKD,kBAAmBC,KAAKc,UAAWd,KAAKJ,qBAIhF,IAAK,MAAOQ,EAAeW,KAAkBC,OAAOC,QAAQjB,KAAKC,oBAAqB,CACpF,MAAMiB,EAAaH,EAAcT,KACjCU,OAAOG,eAAenB,KAAMoB,EAAUF,GAAa,CACjDG,IAAK,IAAMrB,KAAKJ,iBAAiBsB,GACjCI,IAAKC,IACCvB,KAAKwB,aAAapB,IAGpBJ,KAAKyB,aAAarB,EAAemB,GAGnCvB,KAAKJ,iBAAiBsB,GAAcK,EACpCvB,KAAK0B,+BAlCbC,6BAA6BxC,GAC3B,OAAOA,EAAWyC,KAAIC,GAAKxB,EAAUwB,EAAEvB,QAuCzCwB,oBACE,GAAI9B,KAAKF,YACP,MAAM,IAAIiC,MAAM,4BAA4B/B,KAAKc,yDAGnDkB,aAAahC,KAAKiC,wBAGpBC,uBACElC,KAAKiC,uBAAyBE,YAAWC,UACvCpC,KAAKF,aAAc,SACSE,KAAKO,0BACnB8B,YACb,KAGLC,yBAAyBhC,EAAciC,EAAkBhB,GACvD,MAAMR,EAAgBf,KAAKC,mBAAmBK,GAC1CS,IACFf,KAAKJ,iBAAiBmB,EAAcT,MAAQhB,EAAoBkD,oBAAoBjB,EAAUR,EAAc0B,KAAM1B,EAAcT,MAChIN,KAAK0B,4BAIDU,iCACN,IAAKpC,KAAKH,yBAA0B,CAClCG,KAAKH,0BAA2B,EAIhC,MAAM6C,QAAsB1C,KAAKO,yBACjC,IAAKP,KAAKF,YAAa,CACrB,MAAM6C,EAAuBD,EAAcE,cAAc5C,KAAKJ,kBAC9DI,KAAKH,0BAA2B,QAC1B8C,IAKZhB,2BAA2BkB,EAAwBJ,EAAgCK,GACjF,OAAQL,GACN,IAAK,SACH,OAAOI,EACT,IAAK,UACH,OAAQA,GACN,IAAK,OACL,IAAK,OACH,OAAO,EACT,IAAK,QACL,IAAK,QACH,OAAO,EACT,QACE,MAAM,IAAId,MAAM,0BAA0Bc,qBAAkCC,MAElF,IAAK,SACH,MAAMC,EAASC,OAAOH,GACtB,GAAIG,OAAOC,MAAMF,GACf,MAAM,IAAIhB,MAAM,yBAAyBc,qBAAkCC,MAE3E,OAAOC,EAEX,IAAK,WACH,OAAOF,EAAiBvD,EAAoBkD,oBAAoBK,EAAgB,UAAWC,GAAiB,KAC9G,IAAK,UACH,OAAOD,EAAiBvD,EAAoBkD,oBAAoBK,EAAgB,SAAUC,GAAiB,KAC7G,IAAK,SACH,MAAM,IAAIf,MAAM,kBAAkBe,2HACpC,QACE,MAAM,IAAIf,MAAM,iBAAiBU,qBAAwBK,QAKjE,SAASzC,EAAU6C,GACjB,OAAO9B,EAAU8B,GAAOC,QAAQ,WAAY,OAAOC,cAGrD,SAAShC,EAAU8B,GACjB,OAAOA,EAAM,GAAGE,cAAgBF,EAAMG,UAAU,K","sources":["webpack:///./BlazorCustomElements.ts"],"sourcesContent":["declare const Blazor: any;\r\n\r\n// This function is called by the framework because RegisterAsCustomElement sets it as the initializer function\r\n(window as any).registerBlazorCustomElement = function defaultRegisterCustomElement(elementName: string, parameters: JSComponentParameter[]): void {\r\n  customElements.define(elementName, class ConfiguredBlazorCustomElement extends BlazorCustomElement {\r\n    static get observedAttributes() {\r\n      return BlazorCustomElement.getObservedAttributes(parameters);\r\n    }\r\n\r\n    constructor() {\r\n      super(parameters);\r\n    }\r\n  });\r\n}\r\n\r\nexport class BlazorCustomElement extends HTMLElement {\r\n  private _attributeMappings: { [attributeName: string]: JSComponentParameter };\r\n  private _parameterValues: { [dotNetName: string]: any } = {};\r\n  private _addRootComponentPromise: Promise<any>;\r\n  private _hasPendingSetParameters = true; // The constructor will call setParameters, so it starts true\r\n  private _isDisposed = false;\r\n  private _disposalTimeoutHandle: any;\r\n\r\n  public renderIntoElement = this;\r\n\r\n  // Subclasses will need to call this if they want to retain the built-in behavior for knowing which\r\n  // attribute names to observe, since they have to return it from a static function\r\n  static getObservedAttributes(parameters: JSComponentParameter[]): string[] {\r\n    return parameters.map(p => dasherize(p.name));\r\n  }\r\n\r\n  constructor(parameters: JSComponentParameter[]) {\r\n    super();\r\n\r\n    // Keep track of how we'll map the attributes to parameters\r\n    this._attributeMappings = {};\r\n    parameters.forEach(parameter => {\r\n      const attributeName = dasherize(parameter.name);\r\n      this._attributeMappings[attributeName] = parameter;\r\n    });\r\n\r\n    // Defer until end of execution cycle so that (1) we know the heap is unlocked, and (2) the initial parameter\r\n    // values will be populated from the initial attributes before we send them to .NET\r\n    this._addRootComponentPromise = Promise.resolve().then(() => {\r\n      this._hasPendingSetParameters = false;\r\n      return Blazor.rootComponents.add(this.renderIntoElement, this.localName, this._parameterValues);\r\n    });\r\n\r\n    // Also allow assignment of parameters via properties. This is the only way to set complex-typed values.\r\n    for (const [attributeName, parameterInfo] of Object.entries(this._attributeMappings)) {\r\n      const dotNetName = parameterInfo.name;\r\n      Object.defineProperty(this, camelCase(dotNetName), {\r\n        get: () => this._parameterValues[dotNetName],\r\n        set: newValue => {\r\n          if (this.hasAttribute(attributeName)) {\r\n            // It's nice to keep the DOM in sync with the properties. This set a string representation\r\n            // of the value, but this will get overwritten with the original typed value before we send it to .NET\r\n            this.setAttribute(attributeName, newValue);\r\n          }\r\n\r\n          this._parameterValues[dotNetName] = newValue;\r\n          this._supplyUpdatedParameters();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  connectedCallback() {\r\n    if (this._isDisposed) {\r\n      throw new Error(`Cannot connect component ${this.localName} to the document after it has been disposed.`);\r\n    }\r\n\r\n    clearTimeout(this._disposalTimeoutHandle);\r\n  }\r\n\r\n  disconnectedCallback() {\r\n    this._disposalTimeoutHandle = setTimeout(async () => {\r\n      this._isDisposed = true;\r\n      const rootComponent = await this._addRootComponentPromise;\r\n      rootComponent.dispose();\r\n    }, 1000);\r\n  }\r\n\r\n  attributeChangedCallback(name: string, oldValue: string, newValue: string) {\r\n    const parameterInfo = this._attributeMappings[name];\r\n    if (parameterInfo) {\r\n      this._parameterValues[parameterInfo.name] = BlazorCustomElement.parseAttributeValue(newValue, parameterInfo.type, parameterInfo.name);\r\n      this._supplyUpdatedParameters();\r\n    }\r\n  }\r\n\r\n  private async _supplyUpdatedParameters() {\r\n    if (!this._hasPendingSetParameters) {\r\n      this._hasPendingSetParameters = true;\r\n\r\n      // Continuation from here will always be async, so at the earliest it will be at\r\n      // the end of the current JS execution cycle\r\n      const rootComponent = await this._addRootComponentPromise;\r\n      if (!this._isDisposed) {\r\n        const setParametersPromise = rootComponent.setParameters(this._parameterValues);\r\n        this._hasPendingSetParameters = false; // We just snapshotted _parameterValues, so we need to start allowing new calls in case it changes further\r\n        await setParametersPromise;\r\n      }\r\n    }\r\n  }\r\n\r\n  static parseAttributeValue(attributeValue: string, type: JSComponentParameterType, parameterName: string): any {\r\n    switch (type) {\r\n      case 'string':\r\n        return attributeValue;\r\n      case 'boolean':\r\n        switch (attributeValue) {\r\n          case 'true':\r\n          case 'True':\r\n            return true;\r\n          case 'false':\r\n          case 'False':\r\n            return false;\r\n          default:\r\n            throw new Error(`Invalid boolean value '${attributeValue}' for parameter '${parameterName}'`);\r\n        }\r\n      case 'number':\r\n        const number = Number(attributeValue);\r\n        if (Number.isNaN(number)) {\r\n          throw new Error(`Invalid number value '${attributeValue}' for parameter '${parameterName}'`);\r\n        } else {\r\n          return number;\r\n        }\r\n      case 'boolean?':\r\n        return attributeValue ? BlazorCustomElement.parseAttributeValue(attributeValue, 'boolean', parameterName) : null;\r\n      case 'number?':\r\n        return attributeValue ? BlazorCustomElement.parseAttributeValue(attributeValue, 'number', parameterName) : null;\r\n      case 'object':\r\n        throw new Error(`The parameter '${parameterName}' accepts a complex-typed object so it cannot be set using an attribute. Try setting it as a element property instead.`);\r\n      default:\r\n        throw new Error(`Unknown type '${type}' for parameter '${parameterName}'`);\r\n    }\r\n  }\r\n}\r\n\r\nfunction dasherize(value: string): string {\r\n  return camelCase(value).replace(/([A-Z])/g, \"-$1\").toLowerCase();\r\n}\r\n\r\nfunction camelCase(value: string): string {\r\n  return value[0].toLowerCase() + value.substring(1);\r\n}\r\n\r\ninterface JSComponentParameter {\r\n  name: string;\r\n  type: JSComponentParameterType;\r\n}\r\n\r\n// JSON-primitive types, plus for those whose .NET equivalent isn't nullable, a '?' to indicate nullability\r\n// This allows custom element authors to coerce attribute strings into the appropriate type\r\ntype JSComponentParameterType = 'string' | 'boolean' | 'boolean?' | 'number' | 'number?' | 'object';\r\n"],"names":["window","registerBlazorCustomElement","elementName","parameters","customElements","define","BlazorCustomElement","observedAttributes","getObservedAttributes","constructor","super","HTMLElement","_parameterValues","_hasPendingSetParameters","_isDisposed","renderIntoElement","this","_attributeMappings","forEach","parameter","attributeName","dasherize","name","_addRootComponentPromise","Promise","resolve","then","Blazor","rootComponents","add","localName","parameterInfo","Object","entries","dotNetName","defineProperty","camelCase","get","set","newValue","hasAttribute","setAttribute","_supplyUpdatedParameters","static","map","p","connectedCallback","Error","clearTimeout","_disposalTimeoutHandle","disconnectedCallback","setTimeout","async","dispose","attributeChangedCallback","oldValue","parseAttributeValue","type","rootComponent","setParametersPromise","setParameters","attributeValue","parameterName","number","Number","isNaN","value","replace","toLowerCase","substring"],"sourceRoot":""}