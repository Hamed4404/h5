// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Collections.Concurrent;
using System.Reflection.Metadata;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Text.Json.Serialization.Metadata;

[assembly: MetadataUpdateHandler(typeof(JsonSerializerOptionsCache.MetadataUpdateHandler))]

internal sealed class JsonSerializerOptionsCache
{
    private readonly JsonSerializerOptions _baseOptions;

    // We expect JSON type info resolvers to be long-lived objects in most cases. This is because they'll
    // typically be generated by the JSON source generator and referenced via generated static properties.
    // Therefore, we shouldn't need to worry about type info resolvers not getting GC'd due to referencing
    // them here.
    private readonly ConcurrentDictionary<IJsonTypeInfoResolver, JsonSerializerOptions> _cachedSerializerOptions = [];

    public JsonSerializerOptionsCache(JsonSerializerOptions baseOptions)
    {
        _baseOptions = baseOptions;

        if (MetadataUpdater.IsSupported)
        {
            TrackInstance(this);
        }
    }

    public JsonSerializerOptions GetOrAdd(
        IJsonTypeInfoResolver? resolver,
        Func<IJsonTypeInfoResolver, IJsonTypeInfoResolver>? valueFactory = null)
    {
        if (resolver is null)
        {
            return _baseOptions;
        }

        return _cachedSerializerOptions.GetOrAdd(resolver, static (resolver, args) =>
        {
            if (args.valueFactory is not null)
            {
                resolver = args.valueFactory(resolver);
            }

            return new JsonSerializerOptions(args.cache._baseOptions)
            {
                TypeInfoResolver = resolver,
            };
        }, (cache: this, valueFactory));
    }

    private static void TrackInstance(JsonSerializerOptionsCache instance)
        => TrackedJsonSerializerOptionsCaches.All.Add(instance, null);

    internal static class TrackedJsonSerializerOptionsCaches
    {
        // Tracks all live JSRuntime instances. All instances add themselves to this table in their
        // constructor when hot reload is enabled.
        public static readonly ConditionalWeakTable<JsonSerializerOptionsCache, object?> All = [];
    }

    internal static class MetadataUpdateHandler
    {
        public static void ClearCache(Type[]? _)
        {
            foreach (var (cache, _) in TrackedJsonSerializerOptionsCaches.All)
            {
                cache._cachedSerializerOptions.Clear();
            }
        }
    }
}
